module flask::sbuck {

    // Dependencies

    use std::type_name::{Self, TypeName};
    use std::u64::{diff, pow};
    use sui::coin::{Self, Coin, TreasuryCap};
    use sui::balance::{Self, Balance, Supply};
    use sui::url;
    use sui::package::{UpgradeCap};
    use sui::vec_set::{Self, VecSet};
    use sui::dynamic_field as df;
    use flask::event;
    use flask::float::{Self as f, Float};
    
    // Errors

    const ERR_WRONG_VERSION: u64 = 0;
    fun err_wrong_version() { abort ERR_WRONG_VERSION }

    const ERR_INVALID_UPGRADE_CAP: u64 = 1;
    fun err_invalid_upgrade_cap() { abort ERR_INVALID_UPGRADE_CAP }

    const ERR_INVALID_SHARE_INPUT: u64 = 2;
    fun err_invalid_share_input() { abort ERR_INVALID_SHARE_INPUT }

    const ERR_INPUT_TOO_SMALL: u64 = 3;
    fun err_input_too_small() { abort ERR_INPUT_TOO_SMALL }

    const ERR_PATCH_ALREADY_EXISTS: u64 = 4;
    fun err_patch_already_exists() { abort ERR_PATCH_ALREADY_EXISTS }

    const ERR_NOT_WHITELISTED_PROTOCOL: u64 = 5;
    fun err_not_whitelisted_protocol() { abort ERR_NOT_WHITELISTED_PROTOCOL }

    const ERR_FUNCTION_DEPRECATED: u64 = 99;

    // Constants

    const PACKAGE_VERSION: u64 = 2;
    public fun package_version(): u64 { PACKAGE_VERSION }
    
    const SBUCK_DECIMALS: u8 = 9;
    public fun sbuck_decimals(): u8 { SBUCK_DECIMALS }

    const WHITELIST_KEY: u16 = 0;

    // OTW
    public struct SBUCK has drop {}
    
    // Main Object
    public struct Flask<phantom T> has key {
        id: UID,
        version: u64,
        reserves: Balance<T>,
        sbuck_supply: Supply<SBUCK>,
    }

    public struct WhitelistCap has key, store {
        id: UID,
    }

    // Constructor

    fun init(witness: SBUCK, ctx: &mut TxContext) {
        let (sbuck_treasury_cap, sbuck_metadata) = coin::create_currency(
            witness,
            SBUCK_DECIMALS,
            b"sBUCK",
            b"Savings BUCK",
            b"yield bearing stablecoin receive the yield generated by Bucket protocol",
            option::some(url::new_unsafe_from_bytes(
                b"https://ipfs.io/ipfs/QmSXhXefmyiwVYLvHNrkXMkY46U1Z7GDGz66Lhoo4Bz3Cx"),
            ),
            ctx,
        );
        transfer::public_transfer(sbuck_treasury_cap, ctx.sender());
        transfer::public_freeze_object(sbuck_metadata);
        let w_cap = WhitelistCap { id: object::new(ctx) };
        transfer::public_transfer(w_cap, ctx.sender());
    }

    // consume treasury cap to create Supply
    entry public fun initialize<T>(
        sbuck_treasury_cap: TreasuryCap<SBUCK>,
        ctx: &mut TxContext
    ) {
        let flask = Flask<T>{
            id: object::new(ctx),
            version: package_version(),
            reserves: balance::zero<T>(),
            sbuck_supply: coin::treasury_into_supply(sbuck_treasury_cap)
        };

        transfer::share_object(flask);
    }

    public fun collect_rewards<T>(
        self: &mut Flask<T>,
        rewards: Balance<T>
    ) {
        self.assert_package_version();
        event::collect_rewards(rewards.value());
        self.reserves.join(rewards);
    }

    // [deprecated]
    public fun deposit<T>(
        _self: &mut Flask<T>,
        _deposit: Coin<T>
    ): Balance<SBUCK> {
        abort ERR_FUNCTION_DEPRECATED
    }

    // [deprecated]
    public fun withdraw<T>(
        _self: &mut Flask<T>,
        _shares: Coin<SBUCK>
    ): Balance<T> {
        abort ERR_FUNCTION_DEPRECATED
    }

    // Whitelist Funs

    public fun deposit_by_protocol<T, P: drop>(
        self: &mut Flask<T>,
        _: P,
        buck_in: Balance<T>,
    ): Balance<SBUCK> {
        // checks
        self.assert_package_version();
        self.assert_is_whitelisted_protocol<T, P>();
        let buck_in_amount = buck_in.value();
        let sbuck_out_amount = if (self.sbuck_supply() == 0) {
            buck_in_amount
        } else {
            self.sbuck_out_amount(buck_in_amount)
        };
        if (sbuck_out_amount == 0) err_input_too_small();

        // store buck and mint sbuck
        event::deposit(buck_in_amount, sbuck_out_amount);
        self.reserves.join(buck_in);
        self.sbuck_supply.increase_supply(sbuck_out_amount)
    }

    public fun withdraw_by_protocol<T, P: drop>(
        self: &mut Flask<T>,
        _: P,
        sbuck_in: Balance<SBUCK>,
    ): Balance<T> {
        // checks
        self.assert_package_version();
        self.assert_is_whitelisted_protocol<T, P>();
        let sbuck_in_amount = sbuck_in.value();
        let buck_out_amount = self.claimable(sbuck_in_amount);
        if (buck_out_amount == 0) err_input_too_small();

        // burn sbuck and return buck
        event::burn(sbuck_in_amount, buck_out_amount);
        balance::decrease_supply(&mut self.sbuck_supply, sbuck_in);
        balance::split(&mut self.reserves, buck_out_amount)
    }
    
    public fun patch_whitelist<T, P: drop>(
        self: &mut Flask<T>,
        cap: &UpgradeCap,
        cap_owner: address,
        ctx: &mut TxContext,
    ) {
        assert_upgrade_cap(cap);
        let key = WHITELIST_KEY;
        if (df::exists_with_type<u16, VecSet<TypeName>>(&self.id, key))
            err_patch_already_exists();
        df::add(
            &mut self.id,
            key,
            vec_set::singleton(type_name::get<P>())
        );
        let cap = WhitelistCap { id: object::new(ctx) };
        transfer::transfer(cap, cap_owner);
    }

    // Admin Cap

    public fun update_version<T>(
        self: &mut Flask<T>,
        cap: &UpgradeCap,
        version: u64,
    ) {
        assert_upgrade_cap(cap);
        self.version = version;
    }

    public fun add_protocol<T, P: drop>(
        self: &mut Flask<T>,
        _: &WhitelistCap,
    ) {
        self.whitelist_mut()
            .insert(type_name::get<P>());
    }

    public fun remove_protocol<T, P: drop>(
        self: &mut Flask<T>,
        _: &WhitelistCap,
    ) {
        self.whitelist_mut()
            .remove(&type_name::get<P>());
    }

    // Getter Funs

    public fun reserves<T>(self: &Flask<T>): u64 {
        self.reserves.value()
    }

    public fun sbuck_supply<T>(self: &Flask<T>): u64 {
        self.sbuck_supply.supply_value()
    }

    public fun reserves_to_supply<T>(self: &Flask<T>): u64 {
        self.claimable(pow(10, sbuck_decimals())) // shares = 1 sBUCK
    }

    public fun claim_ratio<T>(self: &Flask<T>): Float {
        f::from_fraction(self.reserves(), self.sbuck_supply())
    }

    public fun share_ratio<T>(self: &Flask<T>): Float {
        f::from_fraction(self.sbuck_supply(), self.reserves())
    }

    public fun sbuck_out_amount<T>(self: &Flask<T>, buck_in_amount: u64): u64 {
        f::from(buck_in_amount)
            .mul(self.share_ratio())
            .floor()        
    }
    
    public fun claimable<T>(self: &Flask<T>, shares: u64): u64 {
        if (shares > self.sbuck_supply())
            err_invalid_share_input();
        
        f::from(shares)
            .mul(self.claim_ratio())
            .floor()
    }

    public fun version<T>(self: &Flask<T>): u64 { self.version }

    public fun whitelist<T>(self: &Flask<T>): &VecSet<TypeName> {
        let key = WHITELIST_KEY;
        df::borrow<u16, VecSet<TypeName>>(&self.id, key)
    }

    // Internal Funs

    fun assert_package_version<T>(self: &Flask<T>) {
        if (diff(package_version(), self.version()) > 1)
            err_wrong_version();
    }

    fun assert_upgrade_cap(cap: &UpgradeCap) {
        if (object::id(cap) != @upgrade_cap_id.to_id())
            err_invalid_upgrade_cap();
    }

    fun assert_is_whitelisted_protocol<T, P: drop>(self: &Flask<T>) {
        let protocol_name = type_name::get<P>();
        if (!self.whitelist().contains(&protocol_name))
            err_not_whitelisted_protocol();
    }

    fun whitelist_mut<T>(self: &mut Flask<T>): &mut VecSet<TypeName> {
        let key = WHITELIST_KEY;
        df::borrow_mut<u16, VecSet<TypeName>>(&mut self.id, key)
    }

    // Test-only Funs

    #[test_only]
    public fun init_for_testing(ctx: &mut TxContext) { init(SBUCK{}, ctx) }

    #[test_only]
    public fun patch_whitelist_for_testing<T, P: drop>(
        self: &mut Flask<T>,
    ) {
        let key = WHITELIST_KEY;
        if (df::exists_with_type<u16, VecSet<TypeName>>(&self.id, key))
            err_patch_already_exists();
        df::add(
            &mut self.id,
            key,
            vec_set::singleton(type_name::get<P>())
        );
    }
}
